"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/nonprintable.ts":
/*!*********************************!*\
  !*** ./src/lib/nonprintable.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanText: function() { return /* binding */ cleanText; },\n/* harmony export */   defaultCleanOptions: function() { return /* binding */ defaultCleanOptions; },\n/* harmony export */   downloadTextAsFile: function() { return /* binding */ downloadTextAsFile; },\n/* harmony export */   findNonPrintable: function() { return /* binding */ findNonPrintable; },\n/* harmony export */   stripNonPrintable: function() { return /* binding */ stripNonPrintable; },\n/* harmony export */   summarizeNonPrintable: function() { return /* binding */ summarizeNonPrintable; },\n/* harmony export */   visualizeWithTokens: function() { return /* binding */ visualizeWithTokens; }\n/* harmony export */ });\nconst NON_PRINTABLE_REGEX = RegExp(\"[\\\\p{Cc}\\\\p{Cf}\\\\p{Cs}\\\\p{Co}\\\\p{Cn}]\", \"gu\");\nconst NAMED = {\n    0x00: {\n        name: \"NULL\",\n        category: \"Cc\"\n    },\n    0x09: {\n        name: \"TAB\",\n        category: \"Cc\"\n    },\n    0x0a: {\n        name: \"LINE FEED\",\n        category: \"Cc\"\n    },\n    0x0d: {\n        name: \"CARRIAGE RETURN\",\n        category: \"Cc\"\n    },\n    0x200b: {\n        name: \"ZERO WIDTH SPACE\",\n        category: \"Cf\"\n    },\n    0x200c: {\n        name: \"ZERO WIDTH NON-JOINER\",\n        category: \"Cf\"\n    },\n    0x200d: {\n        name: \"ZERO WIDTH JOINER\",\n        category: \"Cf\"\n    },\n    0x00a0: {\n        name: \"NO-BREAK SPACE\",\n        category: \"Zs\"\n    },\n    0x2028: {\n        name: \"LINE SEPARATOR\",\n        category: \"Zl\"\n    },\n    0x2029: {\n        name: \"PARAGRAPH SEPARATOR\",\n        category: \"Zp\"\n    },\n    0x00ad: {\n        name: \"SOFT HYPHEN\",\n        category: \"Cf\"\n    },\n    0x061c: {\n        name: \"ARABIC LETTER MARK\",\n        category: \"Cf\"\n    },\n    0x200e: {\n        name: \"LEFT-TO-RIGHT MARK\",\n        category: \"Cf\"\n    },\n    0x200f: {\n        name: \"RIGHT-TO-LEFT MARK\",\n        category: \"Cf\"\n    },\n    0x202a: {\n        name: \"LEFT-TO-RIGHT EMBEDDING\",\n        category: \"Cf\"\n    },\n    0x202b: {\n        name: \"RIGHT-TO-LEFT EMBEDDING\",\n        category: \"Cf\"\n    },\n    0x202c: {\n        name: \"POP DIRECTIONAL FORMATTING\",\n        category: \"Cf\"\n    },\n    0x202d: {\n        name: \"LEFT-TO-RIGHT OVERRIDE\",\n        category: \"Cf\"\n    },\n    0x202e: {\n        name: \"RIGHT-TO-LEFT OVERRIDE\",\n        category: \"Cf\"\n    },\n    0x2066: {\n        name: \"LEFT-TO-RIGHT ISOLATE\",\n        category: \"Cf\"\n    },\n    0x2067: {\n        name: \"RIGHT-TO-LEFT ISOLATE\",\n        category: \"Cf\"\n    },\n    0x2068: {\n        name: \"FIRST STRONG ISOLATE\",\n        category: \"Cf\"\n    },\n    0x2069: {\n        name: \"POP DIRECTIONAL ISOLATE\",\n        category: \"Cf\"\n    }\n};\nfunction hex(codePoint) {\n    return \"U+\".concat(codePoint.toString(16).toUpperCase().padStart(4, \"0\"));\n}\nfunction classifyToken(codePoint, category) {\n    if (codePoint === 0x200b) return \"token-zwsp\";\n    if (codePoint === 0x00a0) return \"token-nbsp\";\n    if (codePoint === 0x00ad) return \"token-soft\";\n    if (codePoint === 0x200e || codePoint === 0x200f || codePoint === 0x202a || codePoint === 0x202b || codePoint === 0x202c || codePoint === 0x202d || codePoint === 0x202e || codePoint === 0x2066 || codePoint === 0x2067 || codePoint === 0x2068 || codePoint === 0x2069) return \"token-bidi\";\n    if (category.startsWith(\"Cc\")) return \"token-cc\";\n    if (category.startsWith(\"Cf\")) return \"token-cf\";\n    if (category.startsWith(\"Cs\")) return \"token-cs\";\n    if (category.startsWith(\"Co\")) return \"token-co\";\n    if (category.startsWith(\"Cn\")) return \"token-cn\";\n    return \"token-cf\";\n}\nfunction findNonPrintable(input) {\n    const matches = [];\n    const iterator = input.matchAll(NON_PRINTABLE_REGEX);\n    for (const m of iterator){\n        if (m.index === undefined || m[0] === undefined) continue;\n        const char = m[0];\n        const codePoint = char.codePointAt(0);\n        const named = NAMED[codePoint];\n        var _named_name, _named_category;\n        matches.push({\n            index: m.index,\n            char,\n            codePoint,\n            name: (_named_name = named === null || named === void 0 ? void 0 : named.name) !== null && _named_name !== void 0 ? _named_name : hex(codePoint),\n            category: (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\"\n        });\n    }\n    return matches;\n}\nfunction stripNonPrintable(input) {\n    return input.replace(NON_PRINTABLE_REGEX, \"\");\n}\nfunction summarizeNonPrintable(input) {\n    const freq = new Map();\n    const iterator = input.matchAll(NON_PRINTABLE_REGEX);\n    for (const m of iterator){\n        if (m[0] === undefined) continue;\n        const cp = m[0].codePointAt(0);\n        const named = NAMED[cp];\n        const key = cp;\n        var _named_name, _named_category, _freq_get;\n        const current = (_freq_get = freq.get(key)) !== null && _freq_get !== void 0 ? _freq_get : {\n            count: 0,\n            name: (_named_name = named === null || named === void 0 ? void 0 : named.name) !== null && _named_name !== void 0 ? _named_name : hex(cp),\n            category: (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\"\n        };\n        current.count += 1;\n        freq.set(key, current);\n    }\n    return Array.from(freq.entries()).map((param)=>{\n        let [codePoint, v] = param;\n        return {\n            codePoint,\n            name: v.name,\n            category: v.category,\n            count: v.count\n        };\n    }).sort((a, b)=>b.count - a.count || a.codePoint - b.codePoint);\n}\nfunction visualizeWithTokens(input) {\n    const escape = (s)=>s.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    let count = 0;\n    let result = \"\";\n    for(let i = 0; i < input.length;){\n        const cp = input.codePointAt(i);\n        const char = String.fromCodePoint(cp);\n        const isHidden = NON_PRINTABLE_REGEX.test(char);\n        NON_PRINTABLE_REGEX.lastIndex = 0;\n        if (isHidden) {\n            count += 1;\n            const named = NAMED[cp];\n            var _named_name;\n            const name = (_named_name = named === null || named === void 0 ? void 0 : named.name) !== null && _named_name !== void 0 ? _named_name : hex(cp);\n            var _named_category;\n            const category = (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\";\n            const cls = classifyToken(cp, category);\n            const title = \"\".concat(name, \" (\").concat(hex(cp), \") â€” Category \").concat(category);\n            result += '<span class=\"token '.concat(cls, '\" title=\"').concat(escape(title), '\">&#9676;</span>');\n        } else {\n            result += escape(char);\n        }\n        i += char.length;\n    }\n    return {\n        html: result,\n        count\n    };\n}\nfunction defaultCleanOptions() {\n    return {\n        removeCc: true,\n        removeCf: true,\n        removeCs: true,\n        removeCo: true,\n        removeCn: true,\n        preserveTab: true,\n        preserveLF: true,\n        preserveCR: false,\n        removeZWSP: true,\n        nbspToSpace: true,\n        normalizeDashes: true,\n        normalizeQuotes: true\n    };\n}\nconst DASH_MAP = {\n    0x2010: \"-\",\n    0x2011: \"-\",\n    0x2012: \"-\",\n    0x2013: \"-\",\n    0x2014: \"-\",\n    0x2212: \"-\"\n};\nconst QUOTE_MAP = {\n    0x2018: \"'\",\n    0x2019: \"'\",\n    0x201a: \"'\",\n    0x201b: \"'\",\n    0x2032: \"'\",\n    0x201c: '\"',\n    0x201d: '\"',\n    0x201e: '\"',\n    0x201f: '\"',\n    0x2033: '\"'\n};\nfunction cleanText(input, options) {\n    let out = \"\";\n    for(let i = 0; i < input.length;){\n        const cp = input.codePointAt(i);\n        const ch = String.fromCodePoint(cp);\n        // Smart replaces first\n        if (options.nbspToSpace && cp === 0x00a0) {\n            out += \" \";\n            i += ch.length;\n            continue;\n        }\n        if (options.normalizeDashes && DASH_MAP[cp]) {\n            out += DASH_MAP[cp];\n            i += ch.length;\n            continue;\n        }\n        if (options.normalizeQuotes && QUOTE_MAP[cp]) {\n            out += QUOTE_MAP[cp];\n            i += ch.length;\n            continue;\n        }\n        // Remove ZWSP explicitly if requested\n        if (options.removeZWSP && cp === 0x200b) {\n            i += ch.length;\n            continue;\n        }\n        // Category-based removal for non-printables\n        if (NON_PRINTABLE_REGEX.test(ch)) {\n            NON_PRINTABLE_REGEX.lastIndex = 0;\n            // Handle specific control preservations\n            if (cp === 0x09 && options.preserveTab) {\n                out += ch;\n            } else if (cp === 0x0a && options.preserveLF) {\n                out += ch;\n            } else if (cp === 0x0d && options.preserveCR) {\n                out += ch;\n            } else {\n                // Decide by category groups\n                const named = NAMED[cp];\n                var _named_category;\n                const cat = (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\";\n                const shouldRemove = cat.startsWith(\"Cc\") && options.removeCc || cat.startsWith(\"Cf\") && options.removeCf || cat.startsWith(\"Cs\") && options.removeCs || cat.startsWith(\"Co\") && options.removeCo || cat.startsWith(\"Cn\") && options.removeCn;\n                if (!shouldRemove) {\n                    out += ch;\n                }\n            }\n            i += ch.length;\n            continue;\n        }\n        // Default keep\n        out += ch;\n        i += ch.length;\n    }\n    return out;\n}\nfunction downloadTextAsFile(text, filename) {\n    const blob = new Blob([\n        text\n    ], {\n        type: \"text/plain;charset=utf-8\"\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9ucHJpbnRhYmxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFRQSxNQUFNQSxzQkFBc0I7QUFFNUIsTUFBTUMsUUFBNEQ7SUFDaEUsTUFBTTtRQUFFQyxNQUFNO1FBQVFDLFVBQVU7SUFBSztJQUNyQyxNQUFNO1FBQUVELE1BQU07UUFBT0MsVUFBVTtJQUFLO0lBQ3BDLE1BQU07UUFBRUQsTUFBTTtRQUFhQyxVQUFVO0lBQUs7SUFDMUMsTUFBTTtRQUFFRCxNQUFNO1FBQW1CQyxVQUFVO0lBQUs7SUFDaEQsUUFBUTtRQUFFRCxNQUFNO1FBQW9CQyxVQUFVO0lBQUs7SUFDbkQsUUFBUTtRQUFFRCxNQUFNO1FBQXlCQyxVQUFVO0lBQUs7SUFDeEQsUUFBUTtRQUFFRCxNQUFNO1FBQXFCQyxVQUFVO0lBQUs7SUFDcEQsUUFBUTtRQUFFRCxNQUFNO1FBQWtCQyxVQUFVO0lBQUs7SUFDakQsUUFBUTtRQUFFRCxNQUFNO1FBQWtCQyxVQUFVO0lBQUs7SUFDakQsUUFBUTtRQUFFRCxNQUFNO1FBQXVCQyxVQUFVO0lBQUs7SUFDdEQsUUFBUTtRQUFFRCxNQUFNO1FBQWVDLFVBQVU7SUFBSztJQUM5QyxRQUFRO1FBQUVELE1BQU07UUFBc0JDLFVBQVU7SUFBSztJQUNyRCxRQUFRO1FBQUVELE1BQU07UUFBc0JDLFVBQVU7SUFBSztJQUNyRCxRQUFRO1FBQUVELE1BQU07UUFBc0JDLFVBQVU7SUFBSztJQUNyRCxRQUFRO1FBQUVELE1BQU07UUFBMkJDLFVBQVU7SUFBSztJQUMxRCxRQUFRO1FBQUVELE1BQU07UUFBMkJDLFVBQVU7SUFBSztJQUMxRCxRQUFRO1FBQUVELE1BQU07UUFBOEJDLFVBQVU7SUFBSztJQUM3RCxRQUFRO1FBQUVELE1BQU07UUFBMEJDLFVBQVU7SUFBSztJQUN6RCxRQUFRO1FBQUVELE1BQU07UUFBMEJDLFVBQVU7SUFBSztJQUN6RCxRQUFRO1FBQUVELE1BQU07UUFBeUJDLFVBQVU7SUFB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VUFBVSxDQUFDLFNBQVM4RCxRQUFRYixRQUFRLElBQ3hDZ0IsSUFBSWpFLFVBQVUsQ0FBQyxTQUFTOEQsUUFBUVosUUFBUSxJQUN4Q2UsSUFBSWpFLFVBQVUsQ0FBQyxTQUFTOEQsUUFBUVgsUUFBUTtnQkFFM0MsSUFBSSxDQUFDZSxjQUFjO29CQUNqQkgsT0FBT0M7Z0JBQ1Q7WUFDRjtZQUNBNUIsS0FBSzRCLEdBQUczQixNQUFNO1lBQ2Q7UUFDRjtRQUVBLGVBQWU7UUFDZjBCLE9BQU9DO1FBQ1A1QixLQUFLNEIsR0FBRzNCLE1BQU07SUFDaEI7SUFDQSxPQUFPMEI7QUFDVDtBQUVPLFNBQVNJLG1CQUFtQkMsSUFBWSxFQUFFQyxRQUFnQjtJQUMvRCxNQUFNQyxPQUFPLElBQUlDLEtBQUs7UUFBQ0g7S0FBSyxFQUFFO1FBQUVJLE1BQU07SUFBMkI7SUFDakUsTUFBTUMsTUFBTUMsSUFBSUMsZUFBZSxDQUFDTDtJQUNoQyxNQUFNeEMsSUFBSThDLFNBQVNDLGFBQWEsQ0FBQztJQUNqQy9DLEVBQUVnRCxJQUFJLEdBQUdMO0lBQ1QzQyxFQUFFaUQsUUFBUSxHQUFHVjtJQUNiTyxTQUFTSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ25EO0lBQzFCQSxFQUFFb0QsS0FBSztJQUNQcEQsRUFBRXFELE1BQU07SUFDUlQsSUFBSVUsZUFBZSxDQUFDWDtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL25vbnByaW50YWJsZS50cz9iMzRkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIE5vblByaW50YWJsZU1hdGNoID0ge1xyXG4gIGluZGV4OiBudW1iZXI7XHJcbiAgY2hhcjogc3RyaW5nO1xyXG4gIGNvZGVQb2ludDogbnVtYmVyO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBjYXRlZ29yeTogc3RyaW5nO1xyXG59O1xyXG5cclxuY29uc3QgTk9OX1BSSU5UQUJMRV9SRUdFWCA9IC9bXFxwe0NjfVxccHtDZn1cXHB7Q3N9XFxwe0NvfVxccHtDbn1dL2d1O1xyXG5cclxuY29uc3QgTkFNRUQ6IFJlY29yZDxudW1iZXIsIHsgbmFtZTogc3RyaW5nOyBjYXRlZ29yeTogc3RyaW5nIH0+ID0ge1xyXG4gIDB4MDA6IHsgbmFtZTogXCJOVUxMXCIsIGNhdGVnb3J5OiBcIkNjXCIgfSxcclxuICAweDA5OiB7IG5hbWU6IFwiVEFCXCIsIGNhdGVnb3J5OiBcIkNjXCIgfSxcclxuICAweDBhOiB7IG5hbWU6IFwiTElORSBGRUVEXCIsIGNhdGVnb3J5OiBcIkNjXCIgfSxcclxuICAweDBkOiB7IG5hbWU6IFwiQ0FSUklBR0UgUkVUVVJOXCIsIGNhdGVnb3J5OiBcIkNjXCIgfSxcclxuICAweDIwMGI6IHsgbmFtZTogXCJaRVJPIFdJRFRIIFNQQUNFXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwMGM6IHsgbmFtZTogXCJaRVJPIFdJRFRIIE5PTi1KT0lORVJcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjAwZDogeyBuYW1lOiBcIlpFUk8gV0lEVEggSk9JTkVSXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDAwYTA6IHsgbmFtZTogXCJOTy1CUkVBSyBTUEFDRVwiLCBjYXRlZ29yeTogXCJac1wiIH0sXHJcbiAgMHgyMDI4OiB7IG5hbWU6IFwiTElORSBTRVBBUkFUT1JcIiwgY2F0ZWdvcnk6IFwiWmxcIiB9LFxyXG4gIDB4MjAyOTogeyBuYW1lOiBcIlBBUkFHUkFQSCBTRVBBUkFUT1JcIiwgY2F0ZWdvcnk6IFwiWnBcIiB9LFxyXG4gIDB4MDBhZDogeyBuYW1lOiBcIlNPRlQgSFlQSEVOXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDA2MWM6IHsgbmFtZTogXCJBUkFCSUMgTEVUVEVSIE1BUktcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjAwZTogeyBuYW1lOiBcIkxFRlQtVE8tUklHSFQgTUFSS1wiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDBmOiB7IG5hbWU6IFwiUklHSFQtVE8tTEVGVCBNQVJLXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwMmE6IHsgbmFtZTogXCJMRUZULVRPLVJJR0hUIEVNQkVERElOR1wiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDJiOiB7IG5hbWU6IFwiUklHSFQtVE8tTEVGVCBFTUJFRERJTkdcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjAyYzogeyBuYW1lOiBcIlBPUCBESVJFQ1RJT05BTCBGT1JNQVRUSU5HXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwMmQ6IHsgbmFtZTogXCJMRUZULVRPLVJJR0hUIE9WRVJSSURFXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwMmU6IHsgbmFtZTogXCJSSUdIVC1UTy1MRUZUIE9WRVJSSURFXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwNjY6IHsgbmFtZTogXCJMRUZULVRPLVJJR0hUIElTT0xBVEVcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjA2NzogeyBuYW1lOiBcIlJJR0hULVRPLUxFRlQgSVNPTEFURVwiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDY4OiB7IG5hbWU6IFwiRklSU1QgU1RST05HIElTT0xBVEVcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjA2OTogeyBuYW1lOiBcIlBPUCBESVJFQ1RJT05BTCBJU09MQVRFXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIGhleChjb2RlUG9pbnQ6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBVKyR7Y29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDQsIFwiMFwiKX1gO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGFzc2lmeVRva2VuKGNvZGVQb2ludDogbnVtYmVyLCBjYXRlZ29yeTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBpZiAoY29kZVBvaW50ID09PSAweDIwMGIpIHJldHVybiBcInRva2VuLXp3c3BcIjtcclxuICBpZiAoY29kZVBvaW50ID09PSAweDAwYTApIHJldHVybiBcInRva2VuLW5ic3BcIjtcclxuICBpZiAoY29kZVBvaW50ID09PSAweDAwYWQpIHJldHVybiBcInRva2VuLXNvZnRcIjtcclxuICBpZiAoXHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjAwZSB8fFxyXG4gICAgY29kZVBvaW50ID09PSAweDIwMGYgfHxcclxuICAgIGNvZGVQb2ludCA9PT0gMHgyMDJhIHx8XHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjAyYiB8fFxyXG4gICAgY29kZVBvaW50ID09PSAweDIwMmMgfHxcclxuICAgIGNvZGVQb2ludCA9PT0gMHgyMDJkIHx8XHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjAyZSB8fFxyXG4gICAgY29kZVBvaW50ID09PSAweDIwNjYgfHxcclxuICAgIGNvZGVQb2ludCA9PT0gMHgyMDY3IHx8XHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjA2OCB8fFxyXG4gICAgY29kZVBvaW50ID09PSAweDIwNjlcclxuICApIHJldHVybiBcInRva2VuLWJpZGlcIjtcclxuICBpZiAoY2F0ZWdvcnkuc3RhcnRzV2l0aChcIkNjXCIpKSByZXR1cm4gXCJ0b2tlbi1jY1wiO1xyXG4gIGlmIChjYXRlZ29yeS5zdGFydHNXaXRoKFwiQ2ZcIikpIHJldHVybiBcInRva2VuLWNmXCI7XHJcbiAgaWYgKGNhdGVnb3J5LnN0YXJ0c1dpdGgoXCJDc1wiKSkgcmV0dXJuIFwidG9rZW4tY3NcIjtcclxuICBpZiAoY2F0ZWdvcnkuc3RhcnRzV2l0aChcIkNvXCIpKSByZXR1cm4gXCJ0b2tlbi1jb1wiO1xyXG4gIGlmIChjYXRlZ29yeS5zdGFydHNXaXRoKFwiQ25cIikpIHJldHVybiBcInRva2VuLWNuXCI7XHJcbiAgcmV0dXJuIFwidG9rZW4tY2ZcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb25QcmludGFibGUoaW5wdXQ6IHN0cmluZyk6IE5vblByaW50YWJsZU1hdGNoW10ge1xyXG4gIGNvbnN0IG1hdGNoZXM6IE5vblByaW50YWJsZU1hdGNoW10gPSBbXTtcclxuICBjb25zdCBpdGVyYXRvciA9IGlucHV0Lm1hdGNoQWxsKE5PTl9QUklOVEFCTEVfUkVHRVgpO1xyXG4gIGZvciAoY29uc3QgbSBvZiBpdGVyYXRvcikge1xyXG4gICAgaWYgKG0uaW5kZXggPT09IHVuZGVmaW5lZCB8fCBtWzBdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xyXG4gICAgY29uc3QgY2hhciA9IG1bMF07XHJcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBjaGFyLmNvZGVQb2ludEF0KDApITtcclxuICAgIGNvbnN0IG5hbWVkID0gTkFNRURbY29kZVBvaW50XTtcclxuICAgIG1hdGNoZXMucHVzaCh7XHJcbiAgICAgIGluZGV4OiBtLmluZGV4LFxyXG4gICAgICBjaGFyLFxyXG4gICAgICBjb2RlUG9pbnQsXHJcbiAgICAgIG5hbWU6IG5hbWVkPy5uYW1lID8/IGhleChjb2RlUG9pbnQpLFxyXG4gICAgICBjYXRlZ29yeTogbmFtZWQ/LmNhdGVnb3J5ID8/IFwiQypcIixcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbWF0Y2hlcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwTm9uUHJpbnRhYmxlKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKE5PTl9QUklOVEFCTEVfUkVHRVgsIFwiXCIpO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBGcmVxdWVuY3lFbnRyeSA9IHtcclxuICBjb2RlUG9pbnQ6IG51bWJlcjtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgY2F0ZWdvcnk6IHN0cmluZztcclxuICBjb3VudDogbnVtYmVyO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1bW1hcml6ZU5vblByaW50YWJsZShpbnB1dDogc3RyaW5nKTogRnJlcXVlbmN5RW50cnlbXSB7XHJcbiAgY29uc3QgZnJlcSA9IG5ldyBNYXA8bnVtYmVyLCB7IGNvdW50OiBudW1iZXI7IG5hbWU6IHN0cmluZzsgY2F0ZWdvcnk6IHN0cmluZyB9PigpO1xyXG4gIGNvbnN0IGl0ZXJhdG9yID0gaW5wdXQubWF0Y2hBbGwoTk9OX1BSSU5UQUJMRV9SRUdFWCk7XHJcbiAgZm9yIChjb25zdCBtIG9mIGl0ZXJhdG9yKSB7XHJcbiAgICBpZiAobVswXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuICAgIGNvbnN0IGNwID0gbVswXS5jb2RlUG9pbnRBdCgwKSE7XHJcbiAgICBjb25zdCBuYW1lZCA9IE5BTUVEW2NwXTtcclxuICAgIGNvbnN0IGtleSA9IGNwO1xyXG4gICAgY29uc3QgY3VycmVudCA9IGZyZXEuZ2V0KGtleSkgPz8geyBjb3VudDogMCwgbmFtZTogbmFtZWQ/Lm5hbWUgPz8gaGV4KGNwKSwgY2F0ZWdvcnk6IG5hbWVkPy5jYXRlZ29yeSA/PyBcIkMqXCIgfTtcclxuICAgIGN1cnJlbnQuY291bnQgKz0gMTtcclxuICAgIGZyZXEuc2V0KGtleSwgY3VycmVudCk7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheS5mcm9tKGZyZXEuZW50cmllcygpKVxyXG4gICAgLm1hcCgoW2NvZGVQb2ludCwgdl0pID0+ICh7IGNvZGVQb2ludCwgbmFtZTogdi5uYW1lLCBjYXRlZ29yeTogdi5jYXRlZ29yeSwgY291bnQ6IHYuY291bnQgfSkpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQgfHwgYS5jb2RlUG9pbnQgLSBiLmNvZGVQb2ludCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aXN1YWxpemVXaXRoVG9rZW5zKGlucHV0OiBzdHJpbmcpOiB7IGh0bWw6IHN0cmluZzsgY291bnQ6IG51bWJlciB9IHtcclxuICBjb25zdCBlc2NhcGUgPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcclxuICBsZXQgY291bnQgPSAwO1xyXG5cclxuICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKSB7XHJcbiAgICBjb25zdCBjcCA9IGlucHV0LmNvZGVQb2ludEF0KGkpITtcclxuICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjcCk7XHJcbiAgICBjb25zdCBpc0hpZGRlbiA9IE5PTl9QUklOVEFCTEVfUkVHRVgudGVzdChjaGFyKTtcclxuICAgIE5PTl9QUklOVEFCTEVfUkVHRVgubGFzdEluZGV4ID0gMDtcclxuXHJcbiAgICBpZiAoaXNIaWRkZW4pIHtcclxuICAgICAgY291bnQgKz0gMTtcclxuICAgICAgY29uc3QgbmFtZWQgPSBOQU1FRFtjcF07XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lZD8ubmFtZSA/PyBoZXgoY3ApO1xyXG4gICAgICBjb25zdCBjYXRlZ29yeSA9IG5hbWVkPy5jYXRlZ29yeSA/PyBcIkMqXCI7XHJcbiAgICAgIGNvbnN0IGNscyA9IGNsYXNzaWZ5VG9rZW4oY3AsIGNhdGVnb3J5KTtcclxuICAgICAgY29uc3QgdGl0bGUgPSBgJHtuYW1lfSAoJHtoZXgoY3ApfSkg4oCUIENhdGVnb3J5ICR7Y2F0ZWdvcnl9YDtcclxuICAgICAgcmVzdWx0ICs9IGA8c3BhbiBjbGFzcz1cXFwidG9rZW4gJHtjbHN9XFxcIiB0aXRsZT1cXFwiJHtlc2NhcGUodGl0bGUpfVxcXCI+JiM5Njc2Ozwvc3Bhbj5gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0ICs9IGVzY2FwZShjaGFyKTtcclxuICAgIH1cclxuXHJcbiAgICBpICs9IGNoYXIubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgaHRtbDogcmVzdWx0LCBjb3VudCB9O1xyXG59XHJcblxyXG4vLyBDbGVhbmluZyAvIG5vcm1hbGl6YXRpb25cclxuZXhwb3J0IHR5cGUgQ2xlYW5PcHRpb25zID0ge1xyXG4gIHJlbW92ZUNjOiBib29sZWFuO1xyXG4gIHJlbW92ZUNmOiBib29sZWFuO1xyXG4gIHJlbW92ZUNzOiBib29sZWFuO1xyXG4gIHJlbW92ZUNvOiBib29sZWFuO1xyXG4gIHJlbW92ZUNuOiBib29sZWFuO1xyXG4gIHByZXNlcnZlVGFiOiBib29sZWFuO1xyXG4gIHByZXNlcnZlTEY6IGJvb2xlYW47XHJcbiAgcHJlc2VydmVDUjogYm9vbGVhbjtcclxuICByZW1vdmVaV1NQOiBib29sZWFuO1xyXG4gIG5ic3BUb1NwYWNlOiBib29sZWFuO1xyXG4gIG5vcm1hbGl6ZURhc2hlczogYm9vbGVhbjtcclxuICBub3JtYWxpemVRdW90ZXM6IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdENsZWFuT3B0aW9ucygpOiBDbGVhbk9wdGlvbnMge1xyXG4gIHJldHVybiB7XHJcbiAgICByZW1vdmVDYzogdHJ1ZSxcclxuICAgIHJlbW92ZUNmOiB0cnVlLFxyXG4gICAgcmVtb3ZlQ3M6IHRydWUsXHJcbiAgICByZW1vdmVDbzogdHJ1ZSxcclxuICAgIHJlbW92ZUNuOiB0cnVlLFxyXG4gICAgcHJlc2VydmVUYWI6IHRydWUsXHJcbiAgICBwcmVzZXJ2ZUxGOiB0cnVlLFxyXG4gICAgcHJlc2VydmVDUjogZmFsc2UsXHJcbiAgICByZW1vdmVaV1NQOiB0cnVlLFxyXG4gICAgbmJzcFRvU3BhY2U6IHRydWUsXHJcbiAgICBub3JtYWxpemVEYXNoZXM6IHRydWUsXHJcbiAgICBub3JtYWxpemVRdW90ZXM6IHRydWUsXHJcbiAgfTtcclxufVxyXG5cclxuY29uc3QgREFTSF9NQVA6IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7XHJcbiAgMHgyMDEwOiBcIi1cIiwgLy8gaHlwaGVuXHJcbiAgMHgyMDExOiBcIi1cIiwgLy8gbm9uLWJyZWFraW5nIGh5cGhlblxyXG4gIDB4MjAxMjogXCItXCIsIC8vIGZpZ3VyZSBkYXNoXHJcbiAgMHgyMDEzOiBcIi1cIiwgLy8gZW4gZGFzaFxyXG4gIDB4MjAxNDogXCItXCIsIC8vIGVtIGRhc2hcclxuICAweDIyMTI6IFwiLVwiLCAvLyBtaW51cyBzaWduXHJcbn07XHJcblxyXG5jb25zdCBRVU9URV9NQVA6IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7XHJcbiAgMHgyMDE4OiBcIidcIiwgLy8gbGVmdCBzaW5nbGUgcXVvdGF0aW9uIG1hcmtcclxuICAweDIwMTk6IFwiJ1wiLCAvLyByaWdodCBzaW5nbGUgcXVvdGF0aW9uIG1hcmtcclxuICAweDIwMWE6IFwiJ1wiLCAvLyBzaW5nbGUgbG93LTkgcXVvdGF0aW9uIG1hcmtcclxuICAweDIwMWI6IFwiJ1wiLCAvLyBzaW5nbGUgaGlnaC1yZXZlcnNlZC05IHF1b3RhdGlvbiBtYXJrXHJcbiAgMHgyMDMyOiBcIidcIiwgLy8gcHJpbWUgb2Z0ZW4gdXNlZCBhcyBhcG9zdHJvcGhlXHJcbiAgMHgyMDFjOiAnXCInLCAvLyBsZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xyXG4gIDB4MjAxZDogJ1wiJywgLy8gcmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXHJcbiAgMHgyMDFlOiAnXCInLCAvLyBkb3VibGUgbG93LTkgcXVvdGF0aW9uIG1hcmtcclxuICAweDIwMWY6ICdcIicsIC8vIGRvdWJsZSBoaWdoLXJldmVyc2VkLTkgcXVvdGF0aW9uIG1hcmtcclxuICAweDIwMzM6ICdcIicsIC8vIGRvdWJsZSBwcmltZVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuVGV4dChpbnB1dDogc3RyaW5nLCBvcHRpb25zOiBDbGVhbk9wdGlvbnMpOiBzdHJpbmcge1xyXG4gIGxldCBvdXQgPSBcIlwiO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyApIHtcclxuICAgIGNvbnN0IGNwID0gaW5wdXQuY29kZVBvaW50QXQoaSkhO1xyXG4gICAgY29uc3QgY2ggPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjcCk7XHJcblxyXG4gICAgLy8gU21hcnQgcmVwbGFjZXMgZmlyc3RcclxuICAgIGlmIChvcHRpb25zLm5ic3BUb1NwYWNlICYmIGNwID09PSAweDAwYTApIHtcclxuICAgICAgb3V0ICs9IFwiIFwiO1xyXG4gICAgICBpICs9IGNoLmxlbmd0aDtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5ub3JtYWxpemVEYXNoZXMgJiYgREFTSF9NQVBbY3BdKSB7XHJcbiAgICAgIG91dCArPSBEQVNIX01BUFtjcF07XHJcbiAgICAgIGkgKz0gY2gubGVuZ3RoO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLm5vcm1hbGl6ZVF1b3RlcyAmJiBRVU9URV9NQVBbY3BdKSB7XHJcbiAgICAgIG91dCArPSBRVU9URV9NQVBbY3BdO1xyXG4gICAgICBpICs9IGNoLmxlbmd0aDtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIFpXU1AgZXhwbGljaXRseSBpZiByZXF1ZXN0ZWRcclxuICAgIGlmIChvcHRpb25zLnJlbW92ZVpXU1AgJiYgY3AgPT09IDB4MjAwYikge1xyXG4gICAgICBpICs9IGNoLmxlbmd0aDtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2F0ZWdvcnktYmFzZWQgcmVtb3ZhbCBmb3Igbm9uLXByaW50YWJsZXNcclxuICAgIGlmIChOT05fUFJJTlRBQkxFX1JFR0VYLnRlc3QoY2gpKSB7XHJcbiAgICAgIE5PTl9QUklOVEFCTEVfUkVHRVgubGFzdEluZGV4ID0gMDtcclxuICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIGNvbnRyb2wgcHJlc2VydmF0aW9uc1xyXG4gICAgICBpZiAoY3AgPT09IDB4MDkgJiYgb3B0aW9ucy5wcmVzZXJ2ZVRhYikgeyAvLyBUQUJcclxuICAgICAgICBvdXQgKz0gY2g7XHJcbiAgICAgIH0gZWxzZSBpZiAoY3AgPT09IDB4MGEgJiYgb3B0aW9ucy5wcmVzZXJ2ZUxGKSB7IC8vIExGXHJcbiAgICAgICAgb3V0ICs9IGNoO1xyXG4gICAgICB9IGVsc2UgaWYgKGNwID09PSAweDBkICYmIG9wdGlvbnMucHJlc2VydmVDUikgeyAvLyBDUlxyXG4gICAgICAgIG91dCArPSBjaDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBEZWNpZGUgYnkgY2F0ZWdvcnkgZ3JvdXBzXHJcbiAgICAgICAgY29uc3QgbmFtZWQgPSBOQU1FRFtjcF07XHJcbiAgICAgICAgY29uc3QgY2F0ID0gbmFtZWQ/LmNhdGVnb3J5ID8/IFwiQypcIjtcclxuICAgICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSAoXHJcbiAgICAgICAgICAoY2F0LnN0YXJ0c1dpdGgoXCJDY1wiKSAmJiBvcHRpb25zLnJlbW92ZUNjKSB8fFxyXG4gICAgICAgICAgKGNhdC5zdGFydHNXaXRoKFwiQ2ZcIikgJiYgb3B0aW9ucy5yZW1vdmVDZikgfHxcclxuICAgICAgICAgIChjYXQuc3RhcnRzV2l0aChcIkNzXCIpICYmIG9wdGlvbnMucmVtb3ZlQ3MpIHx8XHJcbiAgICAgICAgICAoY2F0LnN0YXJ0c1dpdGgoXCJDb1wiKSAmJiBvcHRpb25zLnJlbW92ZUNvKSB8fFxyXG4gICAgICAgICAgKGNhdC5zdGFydHNXaXRoKFwiQ25cIikgJiYgb3B0aW9ucy5yZW1vdmVDbilcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICghc2hvdWxkUmVtb3ZlKSB7XHJcbiAgICAgICAgICBvdXQgKz0gY2g7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gY2gubGVuZ3RoO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IGtlZXBcclxuICAgIG91dCArPSBjaDtcclxuICAgIGkgKz0gY2gubGVuZ3RoO1xyXG4gIH1cclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRUZXh0QXNGaWxlKHRleHQ6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbdGV4dF0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLThcIiB9KTtcclxuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICBhLmhyZWYgPSB1cmw7XHJcbiAgYS5kb3dubG9hZCA9IGZpbGVuYW1lO1xyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XHJcbiAgYS5jbGljaygpO1xyXG4gIGEucmVtb3ZlKCk7XHJcbiAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xyXG59ICJdLCJuYW1lcyI6WyJOT05fUFJJTlRBQkxFX1JFR0VYIiwiTkFNRUQiLCJuYW1lIiwiY2F0ZWdvcnkiLCJoZXgiLCJjb2RlUG9pbnQiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwicGFkU3RhcnQiLCJjbGFzc2lmeVRva2VuIiwic3RhcnRzV2l0aCIsImZpbmROb25QcmludGFibGUiLCJpbnB1dCIsIm1hdGNoZXMiLCJpdGVyYXRvciIsIm1hdGNoQWxsIiwibSIsImluZGV4IiwidW5kZWZpbmVkIiwiY2hhciIsImNvZGVQb2ludEF0IiwibmFtZWQiLCJwdXNoIiwic3RyaXBOb25QcmludGFibGUiLCJyZXBsYWNlIiwic3VtbWFyaXplTm9uUHJpbnRhYmxlIiwiZnJlcSIsIk1hcCIsImNwIiwia2V5IiwiY3VycmVudCIsImdldCIsImNvdW50Iiwic2V0IiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsInYiLCJzb3J0IiwiYSIsImIiLCJ2aXN1YWxpemVXaXRoVG9rZW5zIiwiZXNjYXBlIiwicyIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiaXNIaWRkZW4iLCJ0ZXN0IiwibGFzdEluZGV4IiwiY2xzIiwidGl0bGUiLCJodG1sIiwiZGVmYXVsdENsZWFuT3B0aW9ucyIsInJlbW92ZUNjIiwicmVtb3ZlQ2YiLCJyZW1vdmVDcyIsInJlbW92ZUNvIiwicmVtb3ZlQ24iLCJwcmVzZXJ2ZVRhYiIsInByZXNlcnZlTEYiLCJwcmVzZXJ2ZUNSIiwicmVtb3ZlWldTUCIsIm5ic3BUb1NwYWNlIiwibm9ybWFsaXplRGFzaGVzIiwibm9ybWFsaXplUXVvdGVzIiwiREFTSF9NQVAiLCJRVU9URV9NQVAiLCJjbGVhblRleHQiLCJvcHRpb25zIiwib3V0IiwiY2giLCJjYXQiLCJzaG91bGRSZW1vdmUiLCJkb3dubG9hZFRleHRBc0ZpbGUiLCJ0ZXh0IiwiZmlsZW5hbWUiLCJibG9iIiwiQmxvYiIsInR5cGUiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZSIsInJldm9rZU9iamVjdFVSTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nonprintable.ts\n"));

/***/ })

});