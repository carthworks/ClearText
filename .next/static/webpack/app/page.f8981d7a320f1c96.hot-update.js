"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/nonprintable.ts":
/*!*********************************!*\
  !*** ./src/lib/nonprintable.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanText: function() { return /* binding */ cleanText; },\n/* harmony export */   defaultCleanOptions: function() { return /* binding */ defaultCleanOptions; },\n/* harmony export */   downloadTextAsFile: function() { return /* binding */ downloadTextAsFile; },\n/* harmony export */   findNonPrintable: function() { return /* binding */ findNonPrintable; },\n/* harmony export */   findNonPrintableWithPositions: function() { return /* binding */ findNonPrintableWithPositions; },\n/* harmony export */   stripNonPrintable: function() { return /* binding */ stripNonPrintable; },\n/* harmony export */   summarizeNonPrintable: function() { return /* binding */ summarizeNonPrintable; },\n/* harmony export */   visualizeWithTokens: function() { return /* binding */ visualizeWithTokens; }\n/* harmony export */ });\nconst NON_PRINTABLE_REGEX = RegExp(\"[\\\\p{Cc}\\\\p{Cf}\\\\p{Cs}\\\\p{Co}\\\\p{Cn}]\", \"gu\");\nconst NAMED = {\n    0x00: {\n        name: \"NULL\",\n        category: \"Cc\"\n    },\n    0x09: {\n        name: \"TAB\",\n        category: \"Cc\"\n    },\n    0x0a: {\n        name: \"LINE FEED\",\n        category: \"Cc\"\n    },\n    0x0d: {\n        name: \"CARRIAGE RETURN\",\n        category: \"Cc\"\n    },\n    0x200b: {\n        name: \"ZERO WIDTH SPACE\",\n        category: \"Cf\"\n    },\n    0x200c: {\n        name: \"ZERO WIDTH NON-JOINER\",\n        category: \"Cf\"\n    },\n    0x200d: {\n        name: \"ZERO WIDTH JOINER\",\n        category: \"Cf\"\n    },\n    0x00a0: {\n        name: \"NO-BREAK SPACE\",\n        category: \"Zs\"\n    },\n    0x2028: {\n        name: \"LINE SEPARATOR\",\n        category: \"Zl\"\n    },\n    0x2029: {\n        name: \"PARAGRAPH SEPARATOR\",\n        category: \"Zp\"\n    },\n    0x00ad: {\n        name: \"SOFT HYPHEN\",\n        category: \"Cf\"\n    },\n    0x061c: {\n        name: \"ARABIC LETTER MARK\",\n        category: \"Cf\"\n    },\n    0x200e: {\n        name: \"LEFT-TO-RIGHT MARK\",\n        category: \"Cf\"\n    },\n    0x200f: {\n        name: \"RIGHT-TO-LEFT MARK\",\n        category: \"Cf\"\n    },\n    0x202a: {\n        name: \"LEFT-TO-RIGHT EMBEDDING\",\n        category: \"Cf\"\n    },\n    0x202b: {\n        name: \"RIGHT-TO-LEFT EMBEDDING\",\n        category: \"Cf\"\n    },\n    0x202c: {\n        name: \"POP DIRECTIONAL FORMATTING\",\n        category: \"Cf\"\n    },\n    0x202d: {\n        name: \"LEFT-TO-RIGHT OVERRIDE\",\n        category: \"Cf\"\n    },\n    0x202e: {\n        name: \"RIGHT-TO-LEFT OVERRIDE\",\n        category: \"Cf\"\n    },\n    0x2066: {\n        name: \"LEFT-TO-RIGHT ISOLATE\",\n        category: \"Cf\"\n    },\n    0x2067: {\n        name: \"RIGHT-TO-LEFT ISOLATE\",\n        category: \"Cf\"\n    },\n    0x2068: {\n        name: \"FIRST STRONG ISOLATE\",\n        category: \"Cf\"\n    },\n    0x2069: {\n        name: \"POP DIRECTIONAL ISOLATE\",\n        category: \"Cf\"\n    }\n};\nfunction hex(codePoint) {\n    return \"U+\".concat(codePoint.toString(16).toUpperCase().padStart(4, \"0\"));\n}\nfunction classifyToken(codePoint, category) {\n    if (codePoint === 0x200b) return \"token-zwsp\";\n    if (codePoint === 0x00a0) return \"token-nbsp\";\n    if (codePoint === 0x00ad) return \"token-soft\";\n    if (codePoint === 0x200e || codePoint === 0x200f || codePoint === 0x202a || codePoint === 0x202b || codePoint === 0x202c || codePoint === 0x202d || codePoint === 0x202e || codePoint === 0x2066 || codePoint === 0x2067 || codePoint === 0x2068 || codePoint === 0x2069) return \"token-bidi\";\n    if (category.startsWith(\"Cc\")) return \"token-cc\";\n    if (category.startsWith(\"Cf\")) return \"token-cf\";\n    if (category.startsWith(\"Cs\")) return \"token-cs\";\n    if (category.startsWith(\"Co\")) return \"token-co\";\n    if (category.startsWith(\"Cn\")) return \"token-cn\";\n    return \"token-cf\";\n}\nfunction findNonPrintable(input) {\n    const matches = [];\n    const iterator = input.matchAll(NON_PRINTABLE_REGEX);\n    for (const m of iterator){\n        if (m.index === undefined || m[0] === undefined) continue;\n        const char = m[0];\n        const codePoint = char.codePointAt(0);\n        const named = NAMED[codePoint];\n        var _named_name, _named_category;\n        matches.push({\n            index: m.index,\n            char,\n            codePoint,\n            name: (_named_name = named === null || named === void 0 ? void 0 : named.name) !== null && _named_name !== void 0 ? _named_name : hex(codePoint),\n            category: (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\"\n        });\n    }\n    return matches;\n}\nfunction findNonPrintableWithPositions(input) {\n    const results = [];\n    let line = 1;\n    let column = 1;\n    for(let i = 0; i < input.length;){\n        const cp = input.codePointAt(i);\n        const ch = String.fromCodePoint(cp);\n        if (NON_PRINTABLE_REGEX.test(ch)) {\n            NON_PRINTABLE_REGEX.lastIndex = 0;\n            const named = NAMED[cp];\n            var _named_name, _named_category;\n            results.push({\n                index: i,\n                char: ch,\n                codePoint: cp,\n                name: (_named_name = named === null || named === void 0 ? void 0 : named.name) !== null && _named_name !== void 0 ? _named_name : hex(cp),\n                category: (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\",\n                line,\n                column\n            });\n        } else {\n            NON_PRINTABLE_REGEX.lastIndex = 0;\n        }\n        // Newline handling (CRLF counts as a single newline)\n        if (cp === 0x0d /* CR */ ) {\n            const next = input.codePointAt(i + ch.length);\n            if (next === 0x0a) {\n                i += ch.length; // consume CR\n                line += 1;\n                column = 1;\n                i += String.fromCodePoint(next).length; // consume LF\n                continue;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else if (cp === 0x0a /* LF */  || cp === 0x2028 /* LS */  || cp === 0x2029 /* PS */ ) {\n            line += 1;\n            column = 1;\n        } else {\n            column += 1;\n        }\n        i += ch.length;\n    }\n    return results;\n}\nfunction stripNonPrintable(input) {\n    return input.replace(NON_PRINTABLE_REGEX, \"\");\n}\nfunction summarizeNonPrintable(input) {\n    const freq = new Map();\n    const iterator = input.matchAll(NON_PRINTABLE_REGEX);\n    for (const m of iterator){\n        if (m[0] === undefined) continue;\n        const cp = m[0].codePointAt(0);\n        const named = NAMED[cp];\n        const key = cp;\n        var _named_name, _named_category, _freq_get;\n        const current = (_freq_get = freq.get(key)) !== null && _freq_get !== void 0 ? _freq_get : {\n            count: 0,\n            name: (_named_name = named === null || named === void 0 ? void 0 : named.name) !== null && _named_name !== void 0 ? _named_name : hex(cp),\n            category: (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\"\n        };\n        current.count += 1;\n        freq.set(key, current);\n    }\n    return Array.from(freq.entries()).map((param)=>{\n        let [codePoint, v] = param;\n        return {\n            codePoint,\n            name: v.name,\n            category: v.category,\n            count: v.count\n        };\n    }).sort((a, b)=>b.count - a.count || a.codePoint - b.codePoint);\n}\nfunction visualizeWithTokens(input) {\n    const escape = (s)=>s.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    let count = 0;\n    let result = \"\";\n    let line = 1;\n    let column = 1;\n    for(let i = 0; i < input.length;){\n        const cp = input.codePointAt(i);\n        const char = String.fromCodePoint(cp);\n        const isHidden = NON_PRINTABLE_REGEX.test(char);\n        NON_PRINTABLE_REGEX.lastIndex = 0;\n        if (isHidden) {\n            count += 1;\n            const named = NAMED[cp];\n            var _named_name;\n            const name = (_named_name = named === null || named === void 0 ? void 0 : named.name) !== null && _named_name !== void 0 ? _named_name : hex(cp);\n            var _named_category;\n            const category = (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\";\n            const cls = classifyToken(cp, category);\n            const title = \"\".concat(name, \" (\").concat(hex(cp), \") — Category \").concat(category, \" — at \").concat(line, \":\").concat(column);\n            result += '<span class=\"token '.concat(cls, '\" title=\"').concat(escape(title), '\">&#9676;</span>');\n        } else {\n            result += escape(char);\n        }\n        // newline handling for title positions\n        if (cp === 0x0d) {\n            const next = input.codePointAt(i + char.length);\n            if (next === 0x0a) {\n                i += char.length;\n                line += 1;\n                column = 1;\n                i += String.fromCodePoint(next).length;\n                continue;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else if (cp === 0x0a || cp === 0x2028 || cp === 0x2029) {\n            line += 1;\n            column = 1;\n        } else {\n            column += 1;\n        }\n        i += char.length;\n    }\n    return {\n        html: result,\n        count\n    };\n}\nfunction defaultCleanOptions() {\n    return {\n        removeCc: true,\n        removeCf: true,\n        removeCs: true,\n        removeCo: true,\n        removeCn: true,\n        preserveTab: true,\n        preserveLF: true,\n        preserveCR: false,\n        removeZWSP: true,\n        nbspToSpace: true,\n        normalizeDashes: true,\n        normalizeQuotes: true\n    };\n}\nconst DASH_MAP = {\n    0x2010: \"-\",\n    0x2011: \"-\",\n    0x2012: \"-\",\n    0x2013: \"-\",\n    0x2014: \"-\",\n    0x2212: \"-\"\n};\nconst QUOTE_MAP = {\n    0x2018: \"'\",\n    0x2019: \"'\",\n    0x201a: \"'\",\n    0x201b: \"'\",\n    0x2032: \"'\",\n    0x201c: '\"',\n    0x201d: '\"',\n    0x201e: '\"',\n    0x201f: '\"',\n    0x2033: '\"'\n};\nfunction cleanText(input, options) {\n    let out = \"\";\n    for(let i = 0; i < input.length;){\n        const cp = input.codePointAt(i);\n        const ch = String.fromCodePoint(cp);\n        if (options.nbspToSpace && cp === 0x00a0) {\n            out += \" \";\n            i += ch.length;\n            continue;\n        }\n        if (options.normalizeDashes && DASH_MAP[cp]) {\n            out += DASH_MAP[cp];\n            i += ch.length;\n            continue;\n        }\n        if (options.normalizeQuotes && QUOTE_MAP[cp]) {\n            out += QUOTE_MAP[cp];\n            i += ch.length;\n            continue;\n        }\n        if (options.removeZWSP && cp === 0x200b) {\n            i += ch.length;\n            continue;\n        }\n        if (NON_PRINTABLE_REGEX.test(ch)) {\n            NON_PRINTABLE_REGEX.lastIndex = 0;\n            if (cp === 0x09 && options.preserveTab) {\n                out += ch;\n            } else if (cp === 0x0a && options.preserveLF) {\n                out += ch;\n            } else if (cp === 0x0d && options.preserveCR) {\n                out += ch;\n            } else {\n                const named = NAMED[cp];\n                var _named_category;\n                const cat = (_named_category = named === null || named === void 0 ? void 0 : named.category) !== null && _named_category !== void 0 ? _named_category : \"C*\";\n                const shouldRemove = cat.startsWith(\"Cc\") && options.removeCc || cat.startsWith(\"Cf\") && options.removeCf || cat.startsWith(\"Cs\") && options.removeCs || cat.startsWith(\"Co\") && options.removeCo || cat.startsWith(\"Cn\") && options.removeCn;\n                if (!shouldRemove) {\n                    out += ch;\n                }\n            }\n            i += ch.length;\n            continue;\n        }\n        out += ch;\n        i += ch.length;\n    }\n    return out;\n}\nfunction downloadTextAsFile(text, filename) {\n    const blob = new Blob([\n        text\n    ], {\n        type: \"text/plain;charset=utf-8\"\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9ucHJpbnRhYmxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYUEsTUFBTUEsc0JBQXNCO0FBRTVCLE1BQU1DLFFBQTREO0lBQ2hFLE1BQU07UUFBRUMsTUFBTTtRQUFRQyxVQUFVO0lBQUs7SUFDckMsTUFBTTtRQUFFRCxNQUFNO1FBQU9DLFVBQVU7SUFBSztJQUNwQyxNQUFNO1FBQUVELE1BQU07UUFBYUMsVUFBVTtJQUFLO0lBQzFDLE1BQU07UUFBRUQsTUFBTTtRQUFtQkMsVUFBVTtJQUFLO0lBQ2hELFFBQVE7UUFBRUQsTUFBTTtRQUFvQkMsVUFBVTtJQUFLO0lBQ25ELFFBQVE7UUFBRUQsTUFBTTtRQUF5QkMsVUFBVTtJQUFLO0lBQ3hELFFBQVE7UUFBRUQsTUFBTTtRQUFxQkMsVUFBVTtJQUFLO0lBQ3BELFFBQVE7UUFBRUQsTUFBTTtRQUFrQkMsVUFBVTtJQUFLO0lBQ2pELFFBQVE7UUFBRUQsTUFBTTtRQUFrQkMsVUFBVTtJQUFLO0lBQ2pELFFBQVE7UUFBRUQsTUFBTTtRQUF1QkMsVUFBVTtJQUFLO0lBQ3RELFFBQVE7UUFBRUQsTUFBTTtRQUFlQyxVQUFVO0lBQUs7SUFDOUMsUUFBUTtRQUFFRCxNQUFNO1FBQXNCQyxVQUFVO0lBQUs7SUFDckQsUUFBUTtRQUFFRCxNQUFNO1FBQXNCQyxVQUFVO0lBQUs7SUFDckQsUUFBUTtRQUFFRCxNQUFNO1FBQXNCQyxVQUFVO0lBQUs7SUFDckQsUUFBUTtRQUFFRCxNQUFNO1FBQTJCQyxVQUFVO0lBQUs7SUFDMUQsUUFBUTtRQUFFRCxNQUFNO1FBQTJCQyxVQUFVO0lBQUs7SUFDMUQsUUFBUTtRQUFFRCxNQUFNO1FBQThCQyxVQUFVO0lBQUs7SUFDN0QsUUFBUTtRQUFFRCxNQUFNO1FBQTBCQyxVQUFVO0lBQUs7SUFDekQsUUFBUTtRQUFFRCxNQUFNO1FBQTBCQyxVQUFVO0lBQUs7SUFDekQsUUFBUTtRQUFFRCxNQUFNO1FBQXlCQyxVQUFVO0lB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QyxFQUFFeUMsSUFBSSxHQUFHTDtJQUNUcEMsRUFBRTBDLFFBQVEsR0FBR1Y7SUFDYk8sU0FBU0ksSUFBSSxDQUFDQyxXQUFXLENBQUM1QztJQUMxQkEsRUFBRTZDLEtBQUs7SUFDUDdDLEVBQUU4QyxNQUFNO0lBQ1JULElBQUlVLGVBQWUsQ0FBQ1g7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9ub25wcmludGFibGUudHM/YjM0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBOb25QcmludGFibGVNYXRjaCA9IHtcclxuICBpbmRleDogbnVtYmVyO1xyXG4gIGNoYXI6IHN0cmluZztcclxuICBjb2RlUG9pbnQ6IG51bWJlcjtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgY2F0ZWdvcnk6IHN0cmluZztcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFBvc2l0aW9uZWRNYXRjaCA9IE5vblByaW50YWJsZU1hdGNoICYge1xyXG4gIGxpbmU6IG51bWJlcjsgLy8gMS1iYXNlZFxyXG4gIGNvbHVtbjogbnVtYmVyOyAvLyAxLWJhc2VkLCB2aXN1YWwgY29sdW1uIGNvdW50aW5nIGNvZGUgcG9pbnRzXHJcbn07XHJcblxyXG5jb25zdCBOT05fUFJJTlRBQkxFX1JFR0VYID0gL1tcXHB7Q2N9XFxwe0NmfVxccHtDc31cXHB7Q299XFxwe0NufV0vZ3U7XHJcblxyXG5jb25zdCBOQU1FRDogUmVjb3JkPG51bWJlciwgeyBuYW1lOiBzdHJpbmc7IGNhdGVnb3J5OiBzdHJpbmcgfT4gPSB7XHJcbiAgMHgwMDogeyBuYW1lOiBcIk5VTExcIiwgY2F0ZWdvcnk6IFwiQ2NcIiB9LFxyXG4gIDB4MDk6IHsgbmFtZTogXCJUQUJcIiwgY2F0ZWdvcnk6IFwiQ2NcIiB9LFxyXG4gIDB4MGE6IHsgbmFtZTogXCJMSU5FIEZFRURcIiwgY2F0ZWdvcnk6IFwiQ2NcIiB9LFxyXG4gIDB4MGQ6IHsgbmFtZTogXCJDQVJSSUFHRSBSRVRVUk5cIiwgY2F0ZWdvcnk6IFwiQ2NcIiB9LFxyXG4gIDB4MjAwYjogeyBuYW1lOiBcIlpFUk8gV0lEVEggU1BBQ0VcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjAwYzogeyBuYW1lOiBcIlpFUk8gV0lEVEggTk9OLUpPSU5FUlwiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDBkOiB7IG5hbWU6IFwiWkVSTyBXSURUSCBKT0lORVJcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MDBhMDogeyBuYW1lOiBcIk5PLUJSRUFLIFNQQUNFXCIsIGNhdGVnb3J5OiBcIlpzXCIgfSxcclxuICAweDIwMjg6IHsgbmFtZTogXCJMSU5FIFNFUEFSQVRPUlwiLCBjYXRlZ29yeTogXCJabFwiIH0sXHJcbiAgMHgyMDI5OiB7IG5hbWU6IFwiUEFSQUdSQVBIIFNFUEFSQVRPUlwiLCBjYXRlZ29yeTogXCJacFwiIH0sXHJcbiAgMHgwMGFkOiB7IG5hbWU6IFwiU09GVCBIWVBIRU5cIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MDYxYzogeyBuYW1lOiBcIkFSQUJJQyBMRVRURVIgTUFSS1wiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDBlOiB7IG5hbWU6IFwiTEVGVC1UTy1SSUdIVCBNQVJLXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwMGY6IHsgbmFtZTogXCJSSUdIVC1UTy1MRUZUIE1BUktcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjAyYTogeyBuYW1lOiBcIkxFRlQtVE8tUklHSFQgRU1CRURESU5HXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwMmI6IHsgbmFtZTogXCJSSUdIVC1UTy1MRUZUIEVNQkVERElOR1wiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDJjOiB7IG5hbWU6IFwiUE9QIERJUkVDVElPTkFMIEZPUk1BVFRJTkdcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjAyZDogeyBuYW1lOiBcIkxFRlQtVE8tUklHSFQgT1ZFUlJJREVcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjAyZTogeyBuYW1lOiBcIlJJR0hULVRPLUxFRlQgT1ZFUlJJREVcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG4gIDB4MjA2NjogeyBuYW1lOiBcIkxFRlQtVE8tUklHSFQgSVNPTEFURVwiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDY3OiB7IG5hbWU6IFwiUklHSFQtVE8tTEVGVCBJU09MQVRFXCIsIGNhdGVnb3J5OiBcIkNmXCIgfSxcclxuICAweDIwNjg6IHsgbmFtZTogXCJGSVJTVCBTVFJPTkcgSVNPTEFURVwiLCBjYXRlZ29yeTogXCJDZlwiIH0sXHJcbiAgMHgyMDY5OiB7IG5hbWU6IFwiUE9QIERJUkVDVElPTkFMIElTT0xBVEVcIiwgY2F0ZWdvcnk6IFwiQ2ZcIiB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gaGV4KGNvZGVQb2ludDogbnVtYmVyKTogc3RyaW5nIHtcclxuICByZXR1cm4gYFUrJHtjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoNCwgXCIwXCIpfWA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsYXNzaWZ5VG9rZW4oY29kZVBvaW50OiBudW1iZXIsIGNhdGVnb3J5OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmIChjb2RlUG9pbnQgPT09IDB4MjAwYikgcmV0dXJuIFwidG9rZW4tendzcFwiO1xyXG4gIGlmIChjb2RlUG9pbnQgPT09IDB4MDBhMCkgcmV0dXJuIFwidG9rZW4tbmJzcFwiO1xyXG4gIGlmIChjb2RlUG9pbnQgPT09IDB4MDBhZCkgcmV0dXJuIFwidG9rZW4tc29mdFwiO1xyXG4gIGlmIChcclxuICAgIGNvZGVQb2ludCA9PT0gMHgyMDBlIHx8XHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjAwZiB8fFxyXG4gICAgY29kZVBvaW50ID09PSAweDIwMmEgfHxcclxuICAgIGNvZGVQb2ludCA9PT0gMHgyMDJiIHx8XHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjAyYyB8fFxyXG4gICAgY29kZVBvaW50ID09PSAweDIwMmQgfHxcclxuICAgIGNvZGVQb2ludCA9PT0gMHgyMDJlIHx8XHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjA2NiB8fFxyXG4gICAgY29kZVBvaW50ID09PSAweDIwNjcgfHxcclxuICAgIGNvZGVQb2ludCA9PT0gMHgyMDY4IHx8XHJcbiAgICBjb2RlUG9pbnQgPT09IDB4MjA2OVxyXG4gICkgcmV0dXJuIFwidG9rZW4tYmlkaVwiO1xyXG4gIGlmIChjYXRlZ29yeS5zdGFydHNXaXRoKFwiQ2NcIikpIHJldHVybiBcInRva2VuLWNjXCI7XHJcbiAgaWYgKGNhdGVnb3J5LnN0YXJ0c1dpdGgoXCJDZlwiKSkgcmV0dXJuIFwidG9rZW4tY2ZcIjtcclxuICBpZiAoY2F0ZWdvcnkuc3RhcnRzV2l0aChcIkNzXCIpKSByZXR1cm4gXCJ0b2tlbi1jc1wiO1xyXG4gIGlmIChjYXRlZ29yeS5zdGFydHNXaXRoKFwiQ29cIikpIHJldHVybiBcInRva2VuLWNvXCI7XHJcbiAgaWYgKGNhdGVnb3J5LnN0YXJ0c1dpdGgoXCJDblwiKSkgcmV0dXJuIFwidG9rZW4tY25cIjtcclxuICByZXR1cm4gXCJ0b2tlbi1jZlwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vblByaW50YWJsZShpbnB1dDogc3RyaW5nKTogTm9uUHJpbnRhYmxlTWF0Y2hbXSB7XHJcbiAgY29uc3QgbWF0Y2hlczogTm9uUHJpbnRhYmxlTWF0Y2hbXSA9IFtdO1xyXG4gIGNvbnN0IGl0ZXJhdG9yID0gaW5wdXQubWF0Y2hBbGwoTk9OX1BSSU5UQUJMRV9SRUdFWCk7XHJcbiAgZm9yIChjb25zdCBtIG9mIGl0ZXJhdG9yKSB7XHJcbiAgICBpZiAobS5pbmRleCA9PT0gdW5kZWZpbmVkIHx8IG1bMF0gPT09IHVuZGVmaW5lZCkgY29udGludWU7XHJcbiAgICBjb25zdCBjaGFyID0gbVswXTtcclxuICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoYXIuY29kZVBvaW50QXQoMCkhO1xyXG4gICAgY29uc3QgbmFtZWQgPSBOQU1FRFtjb2RlUG9pbnRdO1xyXG4gICAgbWF0Y2hlcy5wdXNoKHtcclxuICAgICAgaW5kZXg6IG0uaW5kZXgsXHJcbiAgICAgIGNoYXIsXHJcbiAgICAgIGNvZGVQb2ludCxcclxuICAgICAgbmFtZTogbmFtZWQ/Lm5hbWUgPz8gaGV4KGNvZGVQb2ludCksXHJcbiAgICAgIGNhdGVnb3J5OiBuYW1lZD8uY2F0ZWdvcnkgPz8gXCJDKlwiLFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBtYXRjaGVzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vblByaW50YWJsZVdpdGhQb3NpdGlvbnMoaW5wdXQ6IHN0cmluZyk6IFBvc2l0aW9uZWRNYXRjaFtdIHtcclxuICBjb25zdCByZXN1bHRzOiBQb3NpdGlvbmVkTWF0Y2hbXSA9IFtdO1xyXG4gIGxldCBsaW5lID0gMTtcclxuICBsZXQgY29sdW1uID0gMTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKSB7XHJcbiAgICBjb25zdCBjcCA9IGlucHV0LmNvZGVQb2ludEF0KGkpITtcclxuICAgIGNvbnN0IGNoID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cclxuICAgIGlmIChOT05fUFJJTlRBQkxFX1JFR0VYLnRlc3QoY2gpKSB7XHJcbiAgICAgIE5PTl9QUklOVEFCTEVfUkVHRVgubGFzdEluZGV4ID0gMDtcclxuICAgICAgY29uc3QgbmFtZWQgPSBOQU1FRFtjcF07XHJcbiAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgY2hhcjogY2gsXHJcbiAgICAgICAgY29kZVBvaW50OiBjcCxcclxuICAgICAgICBuYW1lOiBuYW1lZD8ubmFtZSA/PyBoZXgoY3ApLFxyXG4gICAgICAgIGNhdGVnb3J5OiBuYW1lZD8uY2F0ZWdvcnkgPz8gXCJDKlwiLFxyXG4gICAgICAgIGxpbmUsXHJcbiAgICAgICAgY29sdW1uLFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIE5PTl9QUklOVEFCTEVfUkVHRVgubGFzdEluZGV4ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOZXdsaW5lIGhhbmRsaW5nIChDUkxGIGNvdW50cyBhcyBhIHNpbmdsZSBuZXdsaW5lKVxyXG4gICAgaWYgKGNwID09PSAweDBkIC8qIENSICovKSB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jb2RlUG9pbnRBdChpICsgY2gubGVuZ3RoKTtcclxuICAgICAgaWYgKG5leHQgPT09IDB4MGEpIHtcclxuICAgICAgICBpICs9IGNoLmxlbmd0aDsgLy8gY29uc3VtZSBDUlxyXG4gICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICBjb2x1bW4gPSAxO1xyXG4gICAgICAgIGkgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQobmV4dCkubGVuZ3RoOyAvLyBjb25zdW1lIExGXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgIGNvbHVtbiA9IDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY3AgPT09IDB4MGEgLyogTEYgKi8gfHwgY3AgPT09IDB4MjAyOCAvKiBMUyAqLyB8fCBjcCA9PT0gMHgyMDI5IC8qIFBTICovKSB7XHJcbiAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgY29sdW1uID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbHVtbiArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGkgKz0gY2gubGVuZ3RoO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0cztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwTm9uUHJpbnRhYmxlKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKE5PTl9QUklOVEFCTEVfUkVHRVgsIFwiXCIpO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBGcmVxdWVuY3lFbnRyeSA9IHtcclxuICBjb2RlUG9pbnQ6IG51bWJlcjtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgY2F0ZWdvcnk6IHN0cmluZztcclxuICBjb3VudDogbnVtYmVyO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1bW1hcml6ZU5vblByaW50YWJsZShpbnB1dDogc3RyaW5nKTogRnJlcXVlbmN5RW50cnlbXSB7XHJcbiAgY29uc3QgZnJlcSA9IG5ldyBNYXA8bnVtYmVyLCB7IGNvdW50OiBudW1iZXI7IG5hbWU6IHN0cmluZzsgY2F0ZWdvcnk6IHN0cmluZyB9PigpO1xyXG4gIGNvbnN0IGl0ZXJhdG9yID0gaW5wdXQubWF0Y2hBbGwoTk9OX1BSSU5UQUJMRV9SRUdFWCk7XHJcbiAgZm9yIChjb25zdCBtIG9mIGl0ZXJhdG9yKSB7XHJcbiAgICBpZiAobVswXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuICAgIGNvbnN0IGNwID0gbVswXS5jb2RlUG9pbnRBdCgwKSE7XHJcbiAgICBjb25zdCBuYW1lZCA9IE5BTUVEW2NwXTtcclxuICAgIGNvbnN0IGtleSA9IGNwO1xyXG4gICAgY29uc3QgY3VycmVudCA9IGZyZXEuZ2V0KGtleSkgPz8geyBjb3VudDogMCwgbmFtZTogbmFtZWQ/Lm5hbWUgPz8gaGV4KGNwKSwgY2F0ZWdvcnk6IG5hbWVkPy5jYXRlZ29yeSA/PyBcIkMqXCIgfTtcclxuICAgIGN1cnJlbnQuY291bnQgKz0gMTtcclxuICAgIGZyZXEuc2V0KGtleSwgY3VycmVudCk7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheS5mcm9tKGZyZXEuZW50cmllcygpKVxyXG4gICAgLm1hcCgoW2NvZGVQb2ludCwgdl0pID0+ICh7IGNvZGVQb2ludCwgbmFtZTogdi5uYW1lLCBjYXRlZ29yeTogdi5jYXRlZ29yeSwgY291bnQ6IHYuY291bnQgfSkpXHJcbiAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQgfHwgYS5jb2RlUG9pbnQgLSBiLmNvZGVQb2ludCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aXN1YWxpemVXaXRoVG9rZW5zKGlucHV0OiBzdHJpbmcpOiB7IGh0bWw6IHN0cmluZzsgY291bnQ6IG51bWJlciB9IHtcclxuICBjb25zdCBlc2NhcGUgPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcclxuICBsZXQgY291bnQgPSAwO1xyXG5cclxuICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICBsZXQgbGluZSA9IDE7XHJcbiAgbGV0IGNvbHVtbiA9IDE7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICkge1xyXG4gICAgY29uc3QgY3AgPSBpbnB1dC5jb2RlUG9pbnRBdChpKSE7XHJcbiAgICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY3ApO1xyXG4gICAgY29uc3QgaXNIaWRkZW4gPSBOT05fUFJJTlRBQkxFX1JFR0VYLnRlc3QoY2hhcik7XHJcbiAgICBOT05fUFJJTlRBQkxFX1JFR0VYLmxhc3RJbmRleCA9IDA7XHJcblxyXG4gICAgaWYgKGlzSGlkZGVuKSB7XHJcbiAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgIGNvbnN0IG5hbWVkID0gTkFNRURbY3BdO1xyXG4gICAgICBjb25zdCBuYW1lID0gbmFtZWQ/Lm5hbWUgPz8gaGV4KGNwKTtcclxuICAgICAgY29uc3QgY2F0ZWdvcnkgPSBuYW1lZD8uY2F0ZWdvcnkgPz8gXCJDKlwiO1xyXG4gICAgICBjb25zdCBjbHMgPSBjbGFzc2lmeVRva2VuKGNwLCBjYXRlZ29yeSk7XHJcbiAgICAgIGNvbnN0IHRpdGxlID0gYCR7bmFtZX0gKCR7aGV4KGNwKX0pIOKAlCBDYXRlZ29yeSAke2NhdGVnb3J5fSDigJQgYXQgJHtsaW5lfToke2NvbHVtbn1gO1xyXG4gICAgICByZXN1bHQgKz0gYDxzcGFuIGNsYXNzPVxcXCJ0b2tlbiAke2Nsc31cXFwiIHRpdGxlPVxcXCIke2VzY2FwZSh0aXRsZSl9XFxcIj4mIzk2NzY7PC9zcGFuPmA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgKz0gZXNjYXBlKGNoYXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG5ld2xpbmUgaGFuZGxpbmcgZm9yIHRpdGxlIHBvc2l0aW9uc1xyXG4gICAgaWYgKGNwID09PSAweDBkKSB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jb2RlUG9pbnRBdChpICsgY2hhci5sZW5ndGgpO1xyXG4gICAgICBpZiAobmV4dCA9PT0gMHgwYSkge1xyXG4gICAgICAgIGkgKz0gY2hhci5sZW5ndGg7XHJcbiAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgIGNvbHVtbiA9IDE7XHJcbiAgICAgICAgaSArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChuZXh0KS5sZW5ndGg7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgIGNvbHVtbiA9IDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY3AgPT09IDB4MGEgfHwgY3AgPT09IDB4MjAyOCB8fCBjcCA9PT0gMHgyMDI5KSB7XHJcbiAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgY29sdW1uID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbHVtbiArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGkgKz0gY2hhci5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBodG1sOiByZXN1bHQsIGNvdW50IH07XHJcbn1cclxuXHJcbi8vIENsZWFuaW5nIC8gbm9ybWFsaXphdGlvblxyXG5leHBvcnQgdHlwZSBDbGVhbk9wdGlvbnMgPSB7XHJcbiAgcmVtb3ZlQ2M6IGJvb2xlYW47XHJcbiAgcmVtb3ZlQ2Y6IGJvb2xlYW47XHJcbiAgcmVtb3ZlQ3M6IGJvb2xlYW47XHJcbiAgcmVtb3ZlQ286IGJvb2xlYW47XHJcbiAgcmVtb3ZlQ246IGJvb2xlYW47XHJcbiAgcHJlc2VydmVUYWI6IGJvb2xlYW47XHJcbiAgcHJlc2VydmVMRjogYm9vbGVhbjtcclxuICBwcmVzZXJ2ZUNSOiBib29sZWFuO1xyXG4gIHJlbW92ZVpXU1A6IGJvb2xlYW47XHJcbiAgbmJzcFRvU3BhY2U6IGJvb2xlYW47XHJcbiAgbm9ybWFsaXplRGFzaGVzOiBib29sZWFuO1xyXG4gIG5vcm1hbGl6ZVF1b3RlczogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Q2xlYW5PcHRpb25zKCk6IENsZWFuT3B0aW9ucyB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlbW92ZUNjOiB0cnVlLFxyXG4gICAgcmVtb3ZlQ2Y6IHRydWUsXHJcbiAgICByZW1vdmVDczogdHJ1ZSxcclxuICAgIHJlbW92ZUNvOiB0cnVlLFxyXG4gICAgcmVtb3ZlQ246IHRydWUsXHJcbiAgICBwcmVzZXJ2ZVRhYjogdHJ1ZSxcclxuICAgIHByZXNlcnZlTEY6IHRydWUsXHJcbiAgICBwcmVzZXJ2ZUNSOiBmYWxzZSxcclxuICAgIHJlbW92ZVpXU1A6IHRydWUsXHJcbiAgICBuYnNwVG9TcGFjZTogdHJ1ZSxcclxuICAgIG5vcm1hbGl6ZURhc2hlczogdHJ1ZSxcclxuICAgIG5vcm1hbGl6ZVF1b3RlczogdHJ1ZSxcclxuICB9O1xyXG59XHJcblxyXG5jb25zdCBEQVNIX01BUDogUmVjb3JkPG51bWJlciwgc3RyaW5nPiA9IHtcclxuICAweDIwMTA6IFwiLVwiLFxyXG4gIDB4MjAxMTogXCItXCIsXHJcbiAgMHgyMDEyOiBcIi1cIixcclxuICAweDIwMTM6IFwiLVwiLFxyXG4gIDB4MjAxNDogXCItXCIsXHJcbiAgMHgyMjEyOiBcIi1cIixcclxufTtcclxuXHJcbmNvbnN0IFFVT1RFX01BUDogUmVjb3JkPG51bWJlciwgc3RyaW5nPiA9IHtcclxuICAweDIwMTg6IFwiJ1wiLFxyXG4gIDB4MjAxOTogXCInXCIsXHJcbiAgMHgyMDFhOiBcIidcIixcclxuICAweDIwMWI6IFwiJ1wiLFxyXG4gIDB4MjAzMjogXCInXCIsXHJcbiAgMHgyMDFjOiAnXCInLFxyXG4gIDB4MjAxZDogJ1wiJyxcclxuICAweDIwMWU6ICdcIicsXHJcbiAgMHgyMDFmOiAnXCInLFxyXG4gIDB4MjAzMzogJ1wiJyxcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhblRleHQoaW5wdXQ6IHN0cmluZywgb3B0aW9uczogQ2xlYW5PcHRpb25zKTogc3RyaW5nIHtcclxuICBsZXQgb3V0ID0gXCJcIjtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKSB7XHJcbiAgICBjb25zdCBjcCA9IGlucHV0LmNvZGVQb2ludEF0KGkpITtcclxuICAgIGNvbnN0IGNoID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cclxuICAgIGlmIChvcHRpb25zLm5ic3BUb1NwYWNlICYmIGNwID09PSAweDAwYTApIHtcclxuICAgICAgb3V0ICs9IFwiIFwiO1xyXG4gICAgICBpICs9IGNoLmxlbmd0aDtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5ub3JtYWxpemVEYXNoZXMgJiYgREFTSF9NQVBbY3BdKSB7XHJcbiAgICAgIG91dCArPSBEQVNIX01BUFtjcF07XHJcbiAgICAgIGkgKz0gY2gubGVuZ3RoO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLm5vcm1hbGl6ZVF1b3RlcyAmJiBRVU9URV9NQVBbY3BdKSB7XHJcbiAgICAgIG91dCArPSBRVU9URV9NQVBbY3BdO1xyXG4gICAgICBpICs9IGNoLmxlbmd0aDtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMucmVtb3ZlWldTUCAmJiBjcCA9PT0gMHgyMDBiKSB7XHJcbiAgICAgIGkgKz0gY2gubGVuZ3RoO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTk9OX1BSSU5UQUJMRV9SRUdFWC50ZXN0KGNoKSkge1xyXG4gICAgICBOT05fUFJJTlRBQkxFX1JFR0VYLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgIGlmIChjcCA9PT0gMHgwOSAmJiBvcHRpb25zLnByZXNlcnZlVGFiKSB7XHJcbiAgICAgICAgb3V0ICs9IGNoO1xyXG4gICAgICB9IGVsc2UgaWYgKGNwID09PSAweDBhICYmIG9wdGlvbnMucHJlc2VydmVMRikge1xyXG4gICAgICAgIG91dCArPSBjaDtcclxuICAgICAgfSBlbHNlIGlmIChjcCA9PT0gMHgwZCAmJiBvcHRpb25zLnByZXNlcnZlQ1IpIHtcclxuICAgICAgICBvdXQgKz0gY2g7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbmFtZWQgPSBOQU1FRFtjcF07XHJcbiAgICAgICAgY29uc3QgY2F0ID0gbmFtZWQ/LmNhdGVnb3J5ID8/IFwiQypcIjtcclxuICAgICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSAoXHJcbiAgICAgICAgICAoY2F0LnN0YXJ0c1dpdGgoXCJDY1wiKSAmJiBvcHRpb25zLnJlbW92ZUNjKSB8fFxyXG4gICAgICAgICAgKGNhdC5zdGFydHNXaXRoKFwiQ2ZcIikgJiYgb3B0aW9ucy5yZW1vdmVDZikgfHxcclxuICAgICAgICAgIChjYXQuc3RhcnRzV2l0aChcIkNzXCIpICYmIG9wdGlvbnMucmVtb3ZlQ3MpIHx8XHJcbiAgICAgICAgICAoY2F0LnN0YXJ0c1dpdGgoXCJDb1wiKSAmJiBvcHRpb25zLnJlbW92ZUNvKSB8fFxyXG4gICAgICAgICAgKGNhdC5zdGFydHNXaXRoKFwiQ25cIikgJiYgb3B0aW9ucy5yZW1vdmVDbilcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICghc2hvdWxkUmVtb3ZlKSB7XHJcbiAgICAgICAgICBvdXQgKz0gY2g7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGkgKz0gY2gubGVuZ3RoO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBvdXQgKz0gY2g7XHJcbiAgICBpICs9IGNoLmxlbmd0aDtcclxuICB9XHJcbiAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkVGV4dEFzRmlsZSh0ZXh0OiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3RleHRdLCB7IHR5cGU6IFwidGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04XCIgfSk7XHJcbiAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgYS5ocmVmID0gdXJsO1xyXG4gIGEuZG93bmxvYWQgPSBmaWxlbmFtZTtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xyXG4gIGEuY2xpY2soKTtcclxuICBhLnJlbW92ZSgpO1xyXG4gIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxufSAiXSwibmFtZXMiOlsiTk9OX1BSSU5UQUJMRV9SRUdFWCIsIk5BTUVEIiwibmFtZSIsImNhdGVnb3J5IiwiaGV4IiwiY29kZVBvaW50IiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsInBhZFN0YXJ0IiwiY2xhc3NpZnlUb2tlbiIsInN0YXJ0c1dpdGgiLCJmaW5kTm9uUHJpbnRhYmxlIiwiaW5wdXQiLCJtYXRjaGVzIiwiaXRlcmF0b3IiLCJtYXRjaEFsbCIsIm0iLCJpbmRleCIsInVuZGVmaW5lZCIsImNoYXIiLCJjb2RlUG9pbnRBdCIsIm5hbWVkIiwicHVzaCIsImZpbmROb25QcmludGFibGVXaXRoUG9zaXRpb25zIiwicmVzdWx0cyIsImxpbmUiLCJjb2x1bW4iLCJpIiwibGVuZ3RoIiwiY3AiLCJjaCIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJ0ZXN0IiwibGFzdEluZGV4IiwibmV4dCIsInN0cmlwTm9uUHJpbnRhYmxlIiwicmVwbGFjZSIsInN1bW1hcml6ZU5vblByaW50YWJsZSIsImZyZXEiLCJNYXAiLCJrZXkiLCJjdXJyZW50IiwiZ2V0IiwiY291bnQiLCJzZXQiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwibWFwIiwidiIsInNvcnQiLCJhIiwiYiIsInZpc3VhbGl6ZVdpdGhUb2tlbnMiLCJlc2NhcGUiLCJzIiwicmVzdWx0IiwiaXNIaWRkZW4iLCJjbHMiLCJ0aXRsZSIsImh0bWwiLCJkZWZhdWx0Q2xlYW5PcHRpb25zIiwicmVtb3ZlQ2MiLCJyZW1vdmVDZiIsInJlbW92ZUNzIiwicmVtb3ZlQ28iLCJyZW1vdmVDbiIsInByZXNlcnZlVGFiIiwicHJlc2VydmVMRiIsInByZXNlcnZlQ1IiLCJyZW1vdmVaV1NQIiwibmJzcFRvU3BhY2UiLCJub3JtYWxpemVEYXNoZXMiLCJub3JtYWxpemVRdW90ZXMiLCJEQVNIX01BUCIsIlFVT1RFX01BUCIsImNsZWFuVGV4dCIsIm9wdGlvbnMiLCJvdXQiLCJjYXQiLCJzaG91bGRSZW1vdmUiLCJkb3dubG9hZFRleHRBc0ZpbGUiLCJ0ZXh0IiwiZmlsZW5hbWUiLCJibG9iIiwiQmxvYiIsInR5cGUiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZSIsInJldm9rZU9iamVjdFVSTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nonprintable.ts\n"));

/***/ })

});